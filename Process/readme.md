# 进程（一）

## 什么是程序
- 程序是完成特定任务的一系列指令集合。

## 什么是进程
- 从用户的角度来看进程是程序的一次执行过程
- 从操作系统的核心来看，进程是操作系统分配的内存、CPU时间片等资源的基本单位。
- 进程是资源分配的最小单位
- 每一个进程都有自己独立的地址空间与执行状态
- 像UNIX这样的多任务操作系统能够让许多程序同时运行，每一个运行着的程序就构成了一个进程

## 进程数据结构
```
*-------*
| 代码段 |
*-------*
| 数据段 |
*-------*
| 堆栈段 |
*-------*
| P C B |
*-------*
```
- 我们进程的静态描述:由三部分组成:PCB、有关程序段和该程序段对其进行操作的数据结构集。
- 进程控制块:用于描述进程情况及控制进程运行所需的全部信息。
- 代码段:是进程中能被进程调度程序在CPU上执行的程序代码段。
- 数据段:一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据

## 进程与程序的区别与联系
- 进程是动态的，程序是静态的
- 进程的生命周期是相对短暂的，而程序是长久的
- 进程数据结构PCB
- 一个进程只能对应一个程序，一个程序可以对应多个进程。

# 进程（二）

## 进程状态变迁
- 基本的三种状态就绪、等待、运行
- Linux当中的进程状态
  - 运行状态（TASK_RUNNING)
  - 可中断睡眠状态（TASK_INTERRUPTIBLE)
  - 不可中断睡眠状态（TASK_UNINTERRUPTIBLE)
  - 暂停状态（TASK_STOPPED)
  - 僵死状态（TASK_ZOMBIE)

![Linux当中的进程状态转移关系图](./mdimg/QQ截图20210528153215.png)

## 进程控制块

- 进程描述信息
  - 进程标识符用于唯一的标识一个进程。
- 进程控制信息
  - 进程当前状态
  - 进程优先级
  - 程序开始地址
  - 各种计时信息
  - 通信信息
- 资源信息
  - 占用内存大小及管理用数据结构指针
  - 交换区相关信息
  - IO设备号、缓冲、设备相关的数结构
  - 文件系统相关指针
- 现场保护信息
  - 寄存器
  - PC
  - 程序状态字PSW
  - 栈指针

## 进程标识
  
- 每个进程都会分配到一个独一无二的数字编号，我们称之为“进程标识”(process identifier),或者就直接叫它PID.
- 是一个正整数，取值范围从2到32768
- 当一个进程被启动时，它会顺序挑选下一个未使用的编号数字做为自己的PID
- 数字1一般为特殊进程init保留的，数字0为内核进程保留

## 进程创建

不同的操作系统所提供的进程创建原语的名称和格式不尽相同，但执行创建进程原语后，操作系统所做的工作却大致相同，都包括以下几点:
- 给新创建的进程分配一个内部标识，在内核中建立进程结构
- 复制父进程的环境
- 为进程分配资源，包括进程映像所需要的所有元素（程序、数据、用户栈等）
- 复制父进程地址空间的内容到该进程地址空间中。
- 置该进程的状态为就绪，插入就绪队列。

## 进程撤消
进程终止时操作系统做以下工作:
- **关闭软中断**:因为进程即将终止而不再处理任何软中断信号
- **回收资源**:释放进程分配的所有资源，如关闭所有已打开文件，释放进程相应的数据结构等;
- **写记帐信息**:将进程在运行过程中所产生的记帐数据（其中包括进程运行时的各种统计信息）记录到一个全局记帐文件中;
- **置该进程为僵死状态**:向父进程发送子进程死的软中断信号，将终止信息status送到指定的存储单元中;
- **转进程调度**:因为此时CPU已经被释放，需要由进程调度进行CPU再分配。

## 终止进程的五种方法
- 从main函数返回
- 调用exit（libc）
- 调用_exit（系统调用）
- 调用abort由信号SIGABRT终止

# 进程（三）

## 复制进程映像
- 使用fork函数得到的子进程从父进程的继承了整个进程的地址空间，包括:进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。
- 子进程与父进程的区别在于:
  1. 父进程设置的锁，子进程不继承
  2. 各自的进程ID和父进程ID不同
  3. 子进程的未决告警被清除
  4. 子进程的未决信号集设置为空集

## fork系统调用
- 包含头文件<sys/types.h>和<unistd.h>
- 函数功能:创建一个子进程
- 函数原型
  - pid_t fork(void);
- 参数:无参数。
- 返回值:
  - 如果成功创建一个子进程，对于父进程来说返回子进程ID
  - 如果成功创建一个子进程，对于子进程来说返回值为0
  - 如果为-1表示创建失败

![](mdimg/QQ截图20210528155230.png)

## 孤儿进程、僵尸进程

- fork系统调用之后，父子进程将交替执行。
- 如果父进程先退出，子进程还没退出那么子进程就变为了**孤儿进程**，其父进程将变为init进程。（注:任何一个进程都必须有父进程)
- 如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为**僵尸进程**。

## 写时复制

- 如果多个进程要读取它们自己的那部分资源的副本，那么复制是不必要的。
- 每个进程只要保存一个指向这个资源的指针就可以了。
- 如果一个进程要修改自己的那份资源的“副本”，那么就会复制那份资源。这就是写时复制的含义

# 进程（四）

## fork之后父子进程共享文件
![](mdimg/QQ截图20210528161353.png)

## fork与vfork
- 在fork还没实现copy on write之前。Unix设计者很关心fork之后立刻执行exec所造成的地址空间浪费，所以引入了vfork系统调用。
- vfork有个限制，子进程必须立刻执行_exit或者exec函数。否则可能出现Segmentation fault。
- 即使fork实现了copy on write，效率也没有vfork高，但是我们不推荐使用vfork，因为几乎每一个vfork的实现，都或多或少存在一定的问题。

## exit与_exit
- exit为c库的函数
- _exit为系统调用
![](mdimg/QQ截图20210529153156.png)

## atexit
- atexit可以注册终止处理程序，ANSI C规定最多可以注册32个终止处理程序。
- 终止处理程序的调用与注册次序相反
```
int atexit(void (*function) (void));
```
注意：atexit也是由C库提供的函数，若是通过_exit退出，则不会调用注册函数。
 
## execve替换进程映像(加载程序)
```
#include <unistd.h>

int execve(const char *pathname, char *const argv[],
          char *const envp[]);
```
- 用于替换进程映像