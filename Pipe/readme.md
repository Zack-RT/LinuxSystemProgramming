# 管道（一）

# 管道
- 管道是Unix中最古老的进程间通信的形式。
- 我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”
- 管道是半双工的，数据只能向一个方向流动;需要双方通信时，需要建立起两个管道
- 只能用于具有共同祖先的进程(具有亲缘关系的进程)之间进行通信;通常，一个管道由一个进程创建，然后该进程调用fork，此后父、子进程之间就可应用该管道。

# 匿名管道pipe
- 包含头文件<unistd.h>
- 功能:创建一无名管道
- 原型
  - int pipe(int fd[2]);
- 参数
  - fd:文件描述符数组，其中fd[0]表示读端, fd[1]表示写端
- 返回值:成功返回0，失败返回错误代码

管道的示意图
![](mdimg/QQ截图20210626002454.png)

# 管道示例程序
- [使用pipe函数](01pipe.c)
- [模拟 ls | wc -w](02pipe.c)

# 管道（二）

## 管道的读写规则
- 当没有数据可读时
  - 0_N0NBL0CK disable: read调用阻塞，即进程暂停执行，一直等到有数据来到为止。
  - 0_ NONBLOCK enable: read调用返回-1，errno值为EAGAIN。
- 如果所有管道写端对应的文件描述符被关闭，则read返回0
- 如果所有管道读端对应的文件描述符被关闭，则write操作会产生信号SIGPIPE
- 当要写入的数据量不大于PIPE_BUF时， linux将保证写入的原子性
- 当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性

## 验证管道的大小
- 思路：创建一个pipe，不断的其中写数据，如果管道满了，write默认会阻塞。
- 代码：[04pipe_size.c](04pipe_size.c)

# 管道（三）

## 命名管道(FIFO)
- 管道应用的一个限制就是只能在具有共同祖先(具有亲缘关系)的进程间通信
- 如果我们想在不相关的进程之间交换数据，可以使用FIF0文件来做这项工作，它经常被称为**命名管道**。
- 命名管道是一种特殊类型的文件

## 命名管道的打开规则
- 命名管道可以从命令行上创建，命令行方法是使用下面这个命令:
```
$ mkfifo filename
```
- 命名管道也可以从程序里创建，相关函数有:
```
int mkfifo(const char *filename,mode_ _t mode);
```
- 如果当前打开操作是为读而打开FIFO时
  - 0_ NONBLOCK disable:阻塞直到有相应进程为写而打开该FIFO
  - 0 NONBLOCK enable:立刻返回成功
- 如果当前打开操作是为写而打开FIFO时
  - 0_ NONBLOCK disable:阻塞直到有相应进程为读而打开该FIFO
  - 0_ NONBLOCK enable:立刻返回失败，错误码为ENXIO


## 匿名管道与命名管道
- 匿名管道由pipe函数创建并打开。
- 命名管道由mkfifo函数创建，打开用open
- FIFO (命名管道)与pipe(匿名管道)之间唯一的区别在它们创建与打开的方式不同，这些工作完成之后，它们具有相同的语义

## 命名管道示例程序

